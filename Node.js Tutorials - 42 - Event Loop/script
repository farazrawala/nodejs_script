"welcome back in this video Let'sunderstand about the all-important eventLoop in node.jslet me Begin by reiterating a few pointsabout async code executionfirstJavaScript is a synchronous blockingsingle threaded languagesecondto make async programming possible weneed the help of Liberty I hope this isclear to youusing these two points let me now painta picture in your mind as to how codetypically executes in the node runtimeon the left we have the V8 engine whichexecutes JavaScript codeit comprises of a memory he and a callstackwhenever you declare variables orfunctions memory is allocated on theHeapwhenever you execute code functions arepushed into the call stack and when thefunction returns it is popped off thecall stackstraightforward last in first outimplementation of the stack datastructureon the right we have libuewhenever you execute an async method itis offloaded to the UVLiberty will then run the task usingnative async mechanisms of the operatingsystem and if that is not possible itwill utilize its thread pool to run thetask ensuring the main thread is notblockedlet's now walk through two simple codeSnippets and understand how the V8engine and libue are used by nodefirst let's take a look at synchronouscode executionon the left we have a simple codesnippetthree console log statements that logfirst second and third one after theotherlet's now walk through the code as ifthe runtime is executing itthe main thread of execution alwaysstarts in the global scopeso the global function if you can callit that is pushed onto the stackthen on line 1 we have a console logstatementthe function is pushed onto the stackand for the sake of understanding thetimeline let's assume this happens atone millisecondfirst is logged to the consolethen the function is popped off thestackexecution comes to line twolet's say at 2 millisecondslog function is again pushed onto thestacksecond is locked to the console and thefunction is popped off the stackfinally execution is on line three andat three milliseconds function is pushedonto the stackthird is locked to the consoleand the function is popped off the stackthere is no more code to execute andGlobal is also popped offthis is pretty much how synchronous codeexecution can be visualized with thenode runtimenext let's take a look at async nescodeexecutionon the left we have another code snippetthree log statements like before butthis time the second log statement iswithin a callback function passed to FSdot read filelet us once again walk through the codeas if the runtime is executing itthe main thread of execution alwaysstarts in the global scope so the globalfunction is pushed onto the stackexecution comes to line one at onemillisecond console.log is pushed ontothe stackfirst is logged in the consoleand the function is popped off the stackexecution now moves on to line twoadd 2 milliseconds the read file methodgets pushed onto the stackin the earlier lecture I mentioned thatread file is an async operation that isoffloaded to libueso what happens now is that the Callbackfunction is handed over to libueJavaScript then simply pops off theread5 method from the call stack becauseits job is done as far as execution ofline 2 is concernedin the background the beauty starts toread the file contents on a separatethreadat 3 milliseconds JavaScript proceeds toline 5. it pushes the log function ontothe stackthird gets locked to the consoleand the function is popped off the stacknow there is no more user written codein the global scope to execute so thecall stack is emptyat about 4 milliseconds let's say thatthe file read task is completed in thethread poolthe associated callback functionis now pushed onto the call stackwithin the Callback function we have thelog statementthat is pushed onto the call stacksecond is locked to the console and thefunction is popped offas there are no more statements toexecute in the Callback functionthat is popped off as wellno more code to run so the globalfunction as we call it is also poppedoff the stackthe console output is going to readfirst third and then secondthis is how the node runtime executes anasynchronous code snippet that uses FSdot read filesimilar execution holds good for otherasync methods as wellI hope it is clear to you as to how codeis executed in the node runtimenow if you've understood this farlet me ask you a few questionswhenever an async task completes in libyat what point does node decide to runthe associated callback function on thecall stackdoes it wait for the call stack to beempty or does it interrupt the normalflow of execution to run the Callbackfunctionwhat about async methods like settimeout and set interval which alsodelay the execution of callback functionF2 async tasks such as set timeout andFs dot read file complete at the sametime how does node decide which callbackfunction to run first on the call stackdoes 1 get priority over the otherat the moment we simply don't knowjust when we thought we understood howcode is executed behind the scenes inthe node runtime it seems to have becomemore complexwell let me tell you all these questionscan be answered by understanding aboutthe core part of liby which is the eventLoopnow what is the event Loop welltechnically it is just a c programbut you can think of event loop as adesign pattern that orchestrates orcoordinates the execution of synchronousand asynchronous code in node.jsand the way we are going to understandhow the event Loop works is a two-stepprocessin this video we will take a look at avisual representation of the event Loopthat will give you a brief overview ofthe different parts that come togetherin the event Loopand then over the next few videos wewill conduct various experiments withcode to better understand the visualrepresentationall right here is how we can visualizethe event LoopI would like to pause and thank deepaljsekara who has written an article whereI first came across a similarrepresentationit has been very useful for me and nowmy job is to make sure you easilyunderstand this as wellnow the event Loop is a loop that isalive as long as your node.jsapplication is up and runningin every iteration of the loop we comeacross six different cueseach queue holds one or more callbackfunctions that need to be eventuallyexecuted on the call stackand of course the type of callbackfunctions are different for each queuefirst we have the timer queue thiscontains callbacks associated with settimeout and set intervalsecond we have the ioqthis contains callbacks associated withall the async methods that we have seenso farexample methods associated with the fsand HTTP modulesthird we have the check queue now thiscontains the callbacks associated with afunction called set immediatethis function is specific to node andit's not something you would come acrosswhen writing JavaScript for the browserfourth we have the close queue thiscontains callbacks associated with theclose event of an async taskfinally we have a micro task Queue atthe centerthis is actually two separate cuesthe first queue is called Next tickqueue and contains callbacks associatedwith a function called process dot nexttake which is again specific to node.jsthe second cue is the promise queuewhich contains callbacks that areassociated with the native promise inJavaScriptand one very important point to note isthat timer IO check and close queues areall part of libubythe two microtask use however are notpart of libueehopefully the color difference conveysthatnevertheless there's still part of thenode runtime and play an important rolein the order of execution of callbacksspeaking of which let's understand thatnextthe arrowheads are already a giveawaybut it is very easy to get confusedso let me explain the priority order ofthe queuesfirst you should know that all userwritten synchronous JavaScript codetakes priority over asynchronous codethat the runtime would like to executewhich means only after the call stack isempty the event Loop comes into picturewithin the event Loop though thesequence of execution follows certainrules and I will warn you there arequite a few rules you have to wrap yourhead aroundlet's go over them one at a timestep oneany callbacks in the micro task queuesare executedfirst tasks in the next queue and onlythen tasks in the promise queueStep 2 all callbacks within the timerqueue are executedstep 3 callbacks in the micro taskqueues if present are executed after theexecution of every callback in the timerqueueagain first tasks in the next queue andthen tasks in the promise queuestep 4all callbacks within the ioq areexecutedstep 5 callbacks in the micro taskqueues if present are executednext to queue followed by promise queuestep 6 all callbacks in the check queueare executedstep 7 callbacks in the micro taskqueues if present are executed after theexecution of every callback in the checkqueueagain first tasks in the next IQ andthen tasks in the promise queuestep 8 all callbacks in the close queueare executedstep 9for one final time in the same Loop themicro task queues are executed next aqueue followed by promise queueat this point if there are morecallbacks to be processed the loop iskept alive for one more run and the samesteps are repeatedon the other handif all callbacks are executed and thereis no more code to process the eventLoop exitsthis is the role libuey's event Loopplays in the execution of async code innode.jsI'm also hopeful that we now haveanswers to the questions we had a fewminutes agofor our first question the answer isthat callback functions are executedonly when the call stack is empty thenormal flow of execution will not beinterrupted to run a callback functionfor our second question we now know thatset timeout and set interval callbacksare given first priorityfor the third question We Now understandthat timer callbacks are executed beforeI O callbacks even if both are ready atthe exact same timeapart from this we also learned about afew other cues that have their ownprioritybut this visual representation here iswhat I want you to imprint in your mindas it is how node executes async codeUnder The Herdif it is now clear as to what the eventLoop is over the next few videos let'sconduct a few different experiments tounderstand and verify the order ofexecution in the event Loopthank you for watching please doconsider subscribing to the channel andI'll see you in the next one"