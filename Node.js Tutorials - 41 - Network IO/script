"welcome backover the past two videos we've run fivedifferent experiments to understand therole of libuey's thread pool whenexecuting async methods like read fileand pbkdf2in this video I want to stay on the sametopic of Liberty and async methods buthighlight a different pointand I'll do that with our nextexperimentfor experiment 6 we're going to use adifferent async methodthis time one that involves the networki ofirst comment out the crypto moduleimportand the call to pvkdf2comment out the thread pool size as wellinstead import the https modulehttps is a secure version of the HTTPmodule we've already seenthe method we are going to invoke is therequest method that makes a request toan endpointlet me copy paste the code to save ussome timerequest accepts a URL and we are makinga request to google.comthe second argument is a callbackfunction which gets access to theresponsewe can add listeners to the data and endeventswithin the end event listenerwe are going to log the time taken forthe requestvery similar to what we were doing withpbk df2finally we end the requestand this call to request is placedinside the for Looplet's now run this code with differentvalues of Max callslet's start with onewhen we run node indexwe see the request takes approximately200 millisecondslet's now change Max calls to dorun node indexand the average is now in the range of200 to 300 millisecondslet's now change Max calls to 4.rerun node indexand the average again lies in the rangeof 200 to 300 millisecondslet's bump it up to sixand six if you can recollect is largerthan the default thread pool sizerun the codeand we see the average is still between200 and 300 millisecondsfinally let's change Max calls to 12.we runand surprisingly the average is stillbetween 200 and 300 millisecondsbased on this experiment we can inferthe following two pointsfirstalthough bothcrypto.pbkdf2 and https dot request areasynchronoushttps dot request method does not seemto use the thread poolwe can infer this by noticing that theaverage time Remains the Same for onerequest or six requests or even 12requestsif threadpool was involved we shouldhave seen a larger average time for morethan four requests which we did notsecondhttps dot request does not seem to beaffected by the number of CPU coreseithereven when running 12 requests at a timethe average time was the same as runningone requesthopefully this makes senseand let me tell you this inference is infact truehttps dot request is a network inputoutput operation and not a CPU boundoperationit does not use the thread poolinstead delegates the work to theoperating system kernel and wheneverpossible it will pull the kernel and seeif the request has completedthis is the reason we see nearly thesame request time when we have 1 4 oreven 12 different requestsall right if this is clear we canconclude this video with the followingpointsin node.js async methods are handled bylibuebut they are handled in one of twodifferent wayseither the native async mechanism or thethread poolwhenever possible libuv will use nativeasync mechanisms in the operating systemso as to avoid blocking the main threadsince this is part of the kernel thereis a different mechanism for eachoperating systemwe have e-pol for Linux KQ for Mac OSand IO completion port on Windowsrelying on Native async mechanisms makesnode scalable as the only limitation isthe operating system kernelexample of this is a network i ooperationon the other handif there is no native async support andthe task is file IO or CPU intensiveLibrary uses the thread pool to avoidblocking the main threadalthough the thread pull preservesasynchronicity with respect to node'smain thread it can still become abottleneck if all threads are busyI hope you now have a clearunderstanding of how async methods arehandled under the hood in node.jsthank you for watching please doconsider subscribing to the channel andI'll see you in the next one"
/w