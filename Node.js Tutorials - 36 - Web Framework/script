welcome back.
 so far in this section we have learned quite a few things about the HTTP module.
how to create a server.
how to access the request information.
how to send a response how to modify the response header how to set a response status how to respond with plain text HTML work with HTML templates and even respond with Json.
more recently we also learned how to route requests to different responses.
now although this works perfectly fine in an Enterprise scale application.
this is not how you would create a server and handle requests.
instead you will rely on a web framework k for node.js.
a framework simply abstracts the load level code allowing you to focus on the requirements than the code itself.
for example angular react view are all Frame works slash libraries that help you build user interfaces without having to rely on the lower level Dom API in JavaScript.
Similarly there are Frameworks to build web or mobile applications without having to directly rely on the HTTP module innode.js.
examples of such Frameworks are Express Nest happy COA and sales.
the build on top of the HTTP module making it easier for you to implement all the features we have seen in this section.
as I mentioned in the very first video in the series Express is a pretty popular node framework and we will learn all about its features in an upcoming series.
for now our focus is on just node.js and that will continue for the rest of the series.
before we proceed though let me quickly summarize what we have learned in this section on built-in modules.
we understand that built-in modules are modules that node ships out of the box.
we learned about the path module which provides utilities for working with file and directory paths.
we then understood the Callback pattern which was required to learn about the events module.
we then learned how to extend from the event emitter class.
next we had a theoretical lecture on character sets and encoding.
that was needed to understand the concept of streams and buffers.
we then took a detour to understand the what and why of asynchronous JavaScript.
then we returned to node.js Concepts and learned about the fs module that allows us to work with the file system.
we then learned about streams in node.js through the fs module.
streams allow efficient handling of data in chunks.
we then learned about pipes which allow us to read and write in a really simple way.
finally we had a look at the HTTP module which allows us to create a server handle requests respond with plain text HTML or Json and also handle routing.
there are a few more built-in modules but these are the important ones that you must know when learning node.js.
now for our next section we're going to take a closer look at node.js under the hood and trust me this is a section that you don't want to miss.
thank you for watching.
if you're enjoying the videos please do leave alike And subscribe to the channel.
I'll see you in the next one"
