"welcome back so far we've seen the orderof execution taking into accountsynchronous code the micro task queuesand the timer queuein this video let's add ioq into thepicturea friendly reminder that you should havewatched the previous three videos beforeproceedingI would like to begin this video bymentioning to queue a callback functioninto the ioq there are a number ofmethodsmost of the async methods from thebuilt-in modules cue the Callbackfunction in the ioqfor this video I will be using the readfile method from FS modulelet's head back to vs code and run ournext experimentfor experiment number six I will bestarting freshlet me copy paste the code to save ussome timeall right let's walk through the codefirst we are importing the fs modulenext we invoke the read file method onthe fs modulewe are reading the current file contentsbut that is not relevant as evident fromthe Callback functionwe are ignoring the arguments and simplylogging this is read file 1.after the call to read file we arequeuing up a callback in the next queueand a callback in the promise queuereally simple as you can seeI want you to now pause the video andtry figure out the outputall right if I run node indexyou can see next tick log statementfirst followed by promise resolvefollowed by read filefrom this we can infercallbacks in the micro task queues areexecuted before callbacks in the ioqlet me now help you visualize theexecution with the event Loopwhen the call stack executes allstatements in our code snippet we end upwith one callback in the next queue onein the promise queue and one in the ioqnow there is no further code to executeand control and does the event Loophere next a queue gets top priorityfollowed by promise queue which is Thenfollowed by ioqfirst call back from the next stickqueue is dq'd and executed which locks amessage to the consolenow that the next queue is empty eventLoop proceeds to the promise queuethe Callback is dq'd and executed on thecall stack logging a message to theconsoleat this point the promise queue is emptyand the event Loop proceeds to the timerqueuesince there are no callbacks in thetimer queue the event Loop press hits tothe ioqwe have one callback which is dq'd andexecuted resulting in the final logmessage in the consolehopefully you're able to follow alongif this is clear let's now jump to thenext experimentfor experiment number seven let me copypaste a slightly different code snippetthis time we still have the same FS dotread file and the log statement in theCallback function but instead of queuingup the micro task queueswe are queuing up the timer queue usinga set timeout with zero second delayI want you to now pause and figure outthe outputall right let's see if you got thisrightI'm going to run node indexwe see the output read file 1 followedby set timeout 1.now this may or may not be the outputyou expectedwhy do I phrase it like that well let mererun node index a couple of times toshow you a strange Behavioryou can see in every run the outputdoesn't seem to be consistentwe have read file 1 followed by settimeout 1 but in the very next run wehave set timer at 1 followed by readfile 1.and this inconsistencyseems to keep upand let me tell you this is bound tohappen when you run the code severaltimes in your computer as wellyou simply cannot guarantee the Callbackfunction from set timeout with a delayof 0 milliseconds will run before theCallback pass to read fileand this will be our inference from theseventh experimentwhen running set timeout with a delay of0 milliseconds along with an i o asyncmethod the order of execution can neverbe guaranteedof course this wouldn't be a codeevolution video if I haven't guessedalready that your next question is whycan the order of execution never beguaranteedso let's understand that nowas it turns out the anomaly is becauseof how a minimum delay is set for timersin Google Chrome if you can searchchromium Dom timer C plus file and clickon the first linkit takes you to the C plus code for theDom timerhere if you search forDom timer colon colon Dom timer we willcome across a very interesting piece ofcodewithin the function bodywe are calculating the interval inmillisecondsbut the calculation seems to be amaximumof 1 millisecondor the user passed an intervalmultiplied by one millisecondwhich means if V pass in 0 millisecondsthe interval is maximum of 1 comma 0which is 1.this will result in a one millisecondset timeout delayit seems that node.js follows a similarimplementationwhen you set 0 milliseconds delay itoverrides to one milliseconds delaybut how does the one millisecond delayaffect the order of the two logstatementslet's understand thatwhen you set 0 milliseconds delay at thestart of the event Loop node.js needs tofigure out if the one millisecond timerhas elapsed or notif event Loop enters the timer at 0.05millisecondsthe one millisecond callback hasn't beenqueued and the control moves on to theioq executing the read file callbackin the next iteration of the event Loopthe timer Q callback will be executedon the other hand if the CPU is busy andenters the timer Queue at 1.01millisecondstimer would have elapsed and theCallback function which is queued in thetimer queue is executed firstthe control will then proceed to ioq andthe read file callback will be executedbecause of this uncertainty in how busythe CPU can be and zero millisecondsdelay being overwritten as onemillisecond delay we can never guaranteethe order of execution between a zeromillisecond timer and an i o callbackit is a slightly Advanced topic tounderstand but hopefully the explanationwas clear enoughand that concludes our seventhexperimentall right for the eighth experimentwhich would be the final experiment inthis video Let's understand the order ofexecution of callbacks in microtaskqueues timer queue and ioq combinedonce again I'm going to copy paste codeto save us some timelet me walk you through the codefirst we have the fs module importwith an invoke read file and pass in acallback function that locks a messageto the consolenext we have process Dot nextdick whichwill add a callback function into thenext stick queuesimilarly we have promise.resolve whichwill add a callback function to thepromise queuefinally we have set timeout which locksa message to the console as wellnow as it stands we still have run intothe timer issue we saw in the lastexperimentto make sure we avoid that I'm going toadd a for Loop that does nothinghowever it will ensure that when controlenters the timer queue the set timertimer has elapsed and the Callback isready to be executedpause for a minute and try figure outthe outputall right let me run node indexwe see next tick callback first followedby promise callback followed by timercallback and at the end IO callbackfrom this we can inferioq callbacks are executed aftermicrotask queue callbacks and timerqueue callbacksvisualization is also prettystraightforwardwhen the call stack executes allstatements we end up with one callbackin the next queueone in the promise queueone in the timer queue and one in theioqthere is no further code to execute andcontrol enters the event gluefirst call back from the next EQ is dq'dand executed which locks a message tothe consolenow that the next queue is empty eventLoop proceeds to the promise queuethe Callback is dq'd and executed on thecall stacklogging a message to the consoleat this point the promise queue is emptyand the event Loop proceeds to the timerqueuethe Callback function is dq'd andexecutedfinally the event Loop proceeds to theioqwe have one callbackwhich is dq'd and executed resulting inthe final log message in the consolehopefully this makes sensewell that is about the ioq and itspriority in the event Loopthank you for watching please do leave alike if you are enjoying the videos asit helps out a lot with the YouTubealgorithm I'll see you in the next one"